#!/usr/bin/env python
#
# Utilities for running parameter sweeps on slurm

import argparse
import datetime
import errno
import getpass
import os
import sys
import time

from subprocess import check_output
from itertools import product

ts = str(datetime.datetime.now()).split('.')[0]
ts = ts.replace(' ', '').replace('-', '').replace(':', '')


def product_dict(**kwargs):
    keys = kwargs.keys()
    vals = kwargs.values()
    for instance in product(*vals):
        yield dict(zip(keys, instance))


def generate_job(jid, params, job_str, env, sbatch_args, job_dir, logs_dir):
    jname = 'job_{}_{}'.format(ts, jid)
    fname = os.path.join(job_dir, jname)
    with open(fname, 'w') as f:
        f.write('#!/bin/bash\n\n')
        f.write('#SBATCH -e {}/{}.err\n'.format(logs_dir, jname))
        f.write('#SBATCH -o {}/{}.out\n'.format(logs_dir, jname))
        f.write('#SBATCH -J {}\n'.format(jname))
        f.write('#SBATCH -N {}\n'.format(params['nodes']))
        for k, v in sbatch_args.items():
            f.write('#SBATCH --{} {}\n'.format(k, v))
        f.write('')
        for k, v in env.items():
            v_eval = check_output('echo "' + v + '"', shell=True)
            f.write('export {}={}'.format(k, v_eval))
        for k, v in params.items():
            f.write('export {}={}\n'.format(k, v))
        f.write('\n{}\n'.format(job_str))
    os.chmod(fname, 0755)


def info(msg):
    print('[slurmp]: ' + msg)


def generate(c, job_file, job_dir, logs_dir):
    # check required items
    if not c.get('params', None):
        info("Expecting 'params' element in configuration.")
    if not c['params'].get('nodes', None):
        info("Expecting 'params.nodes' element in configuration.")

    # check types
    for k, v in c['params'].items():
        if type(v) is not list:
            info("Expecting only lists (arrays) in 'params' dictionary.")
    for k, v in c.get('env', {}).items():
        if type(v) is not str:
            info("Expecting only strings as values in 'env' dictionary.")
    for k, v in c.get('sbatch_args', {}).items():
        if type(v) is not str:
            info("Expecting only strings as values of 'sbatch_args' dict.")

    with open(job_file, 'r') as f:
        job_str = f.read()

    jid = 1
    for p in list(product_dict(**c['params'])):
        generate_job(jid, p, job_str, c['env'],
                     c['sbatch_args'], job_dir, logs_dir)
        jid += 1


def job_files(job_dir):
    for f in os.listdir(job_dir):
        if not os.path.isfile(os.path.join(job_dir, f)):
            continue
        yield f


def run(job_dir):
    for f in job_files(job_dir):
        cmd = 'sbatch {}'.format(os.path.join(job_dir, f))
        check_output(cmd, shell=True)
    info('Submitted jobs successfully!')


def wait(job_dir):
    jobs_all = set(job_files(job_dir))
    jobs_done = set()
    jobs_fail = set()

    done_state = 'CD'
    fail_state = 'BF,CA,DL,F,NF,OOM,SE,ST,S,TO'

    cmd_a = 'squeue --user {u} --name {j} --noheader | wc -l'
    cmd_j = 'squeue --user {u} --name {j} --noheader --states {s} | wc -l'

    u = getpass.getuser()

    info('Waiting for jobs to finish.')

    while (jobs_done | jobs_fail) != jobs_all:

        jobs_remaining = (jobs_all - jobs_done) - jobs_fail

        info('{} jobs remain in the queue'.format(len(jobs_remaining)))

        for j in jobs_remaining:

            s = done_state

            if int(check_output(cmd_a.format(u=u, j=j, s=s), shell=True)) == 0:
                info("Job {} finished (unknown state).".format(j))
                jobs_done.add(j)
                continue

            if int(check_output(cmd_j.format(u=u, j=j, s=s), shell=True)) == 1:
                info('Job {} finished successfully.'.format(j))
                jobs_done.add(j)
                continue

            s = fail_state
            if int(check_output(cmd_j.format(u=u, j=j, s=s), shell=True)) == 1:
                info('Job {} finished (failed!)'.format(j))
                jobs_fail.add(j)

            time.sleep(120)

    info('All jobs finished.')

    if len(jobs_fail) != 0:
        info('')
        info('WARNING: some jobs failed! Check logs folder.')


def mkdir_p(path):
    try:
        os.makedirs(path)
    except OSError as exc:  # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else:
            raise


if __name__ == "__main__":

    parser = argparse.ArgumentParser()

    parser.add_argument(
        '--config',
        help='Path to parameter sweep configuration file.',
        default='./slurm/sweep.py',
        required=False
    )
    parser.add_argument(
        '--job-file',
        help='Job to be used in the generation of the sweep.',
        default="./slurm/job.sh",
        required=False
    )
    parser.add_argument(
        '--job-dir',
        help='Folder where job files are to be written.',
        default="./slurm/jobs",
        required=False
    )
    parser.add_argument(
        '--logs-dir',
        help='Folder where job logs are to be written.',
        default="./slurm/logs",
        required=False
    )
    parser.add_argument(
        '--generate',
        help='Generate jobs for given parameter sweep config.',
        required=False,
        action='store_true'
    )
    parser.add_argument(
        '--run',
        help='Execute a bunch of SLURM jobs contained in the job folder.',
        required=False,
        action='store_true'
    )
    parser.add_argument(
        '--no-wait',
        required=False,
        help='Do not wait for jobs and return after they have been submitted.',
        action='store_true'
    )

    args = vars(parser.parse_args())

    if not args['generate'] and not args['run']:
        print("At least one of --generate or --run is required.")
        sys.exit(1)

    if args['no_wait'] and not args['run']:
        print("The --no-wait flag works only when --run is given.")
        sys.exit(1)

    mkdir_p(args['job_dir'])

    if args['generate']:
        if not os.path.isfile(args['job_file']):
            print('Looks like {} does not exist'.format(args['job_file']))
            sys.exit(1)
        if not os.path.isfile(args['config']):
            print('Looks like {} does not exist'.format(args['config']))
            sys.exit(1)

        with open(args['config'], 'r') as f:
            c = eval(f.read())

        generate(c, args['job_file'], args['job_dir'], args['logs_dir'])

    if args['run']:
        run(args['job_dir'])

        if args['no_wait']:
            sys.exit(0)

        wait(args['job_dir'])
